

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pyzag.chunktime &mdash; pyzag 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=f2a433a1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pyzag.ode" href="ode.html" />
    <link rel="prev" title="pyzag.nonlinear" href="nonlinear.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            pyzag
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Additional topics:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../tutorials/tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="api.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nonlinear.html">pyzag.nonlinear</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pyzag.chunktime</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.BidiagonalForwardOperator"><code class="docutils literal notranslate"><span class="pre">BidiagonalForwardOperator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalForwardOperator.forward"><code class="docutils literal notranslate"><span class="pre">BidiagonalForwardOperator.forward()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalForwardOperator.inverse"><code class="docutils literal notranslate"><span class="pre">BidiagonalForwardOperator.inverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalForwardOperator.matvec"><code class="docutils literal notranslate"><span class="pre">BidiagonalForwardOperator.matvec()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalForwardOperator.to_diag"><code class="docutils literal notranslate"><span class="pre">BidiagonalForwardOperator.to_diag()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalForwardOperator.vecmat"><code class="docutils literal notranslate"><span class="pre">BidiagonalForwardOperator.vecmat()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.BidiagonalHybridFactorization"><code class="docutils literal notranslate"><span class="pre">BidiagonalHybridFactorization()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.BidiagonalHybridFactorizationImpl"><code class="docutils literal notranslate"><span class="pre">BidiagonalHybridFactorizationImpl</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalHybridFactorizationImpl.matvec"><code class="docutils literal notranslate"><span class="pre">BidiagonalHybridFactorizationImpl.matvec()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.BidiagonalOperator"><code class="docutils literal notranslate"><span class="pre">BidiagonalOperator</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalOperator.device"><code class="docutils literal notranslate"><span class="pre">BidiagonalOperator.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalOperator.dtype"><code class="docutils literal notranslate"><span class="pre">BidiagonalOperator.dtype</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalOperator.n"><code class="docutils literal notranslate"><span class="pre">BidiagonalOperator.n</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalOperator.shape"><code class="docutils literal notranslate"><span class="pre">BidiagonalOperator.shape</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.BidiagonalPCRFactorization"><code class="docutils literal notranslate"><span class="pre">BidiagonalPCRFactorization</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalPCRFactorization.matvec"><code class="docutils literal notranslate"><span class="pre">BidiagonalPCRFactorization.matvec()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.BidiagonalThomasFactorization"><code class="docutils literal notranslate"><span class="pre">BidiagonalThomasFactorization</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.BidiagonalThomasFactorization.matvec"><code class="docutils literal notranslate"><span class="pre">BidiagonalThomasFactorization.matvec()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.ChunkNewtonRaphson"><code class="docutils literal notranslate"><span class="pre">ChunkNewtonRaphson</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.ChunkNewtonRaphson.not_converged"><code class="docutils literal notranslate"><span class="pre">ChunkNewtonRaphson.not_converged()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.ChunkNewtonRaphson.solve"><code class="docutils literal notranslate"><span class="pre">ChunkNewtonRaphson.solve()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.ChunkNewtonRaphson.step"><code class="docutils literal notranslate"><span class="pre">ChunkNewtonRaphson.step()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.ChunkNewtonRaphsonLineSearch"><code class="docutils literal notranslate"><span class="pre">ChunkNewtonRaphsonLineSearch</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.ChunkNewtonRaphsonLineSearch.step"><code class="docutils literal notranslate"><span class="pre">ChunkNewtonRaphsonLineSearch.step()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.LUFactorization"><code class="docutils literal notranslate"><span class="pre">LUFactorization</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.LUFactorization.forward"><code class="docutils literal notranslate"><span class="pre">LUFactorization.forward()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.device"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.device</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.dtype"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.dtype</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.n"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.n</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.nnz"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.nnz</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.shape"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.shape</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_batched_coo"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.to_batched_coo()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_dense"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.to_dense()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_unrolled_csr"><code class="docutils literal notranslate"><span class="pre">SquareBatchedBlockDiagonalMatrix.to_unrolled_csr()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pyzag.chunktime.thomas_solve"><code class="docutils literal notranslate"><span class="pre">thomas_solve()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ode.html">pyzag.ode</a></li>
<li class="toctree-l2"><a class="reference internal" href="reparametrization.html">pyzag.reparametrization</a></li>
<li class="toctree-l2"><a class="reference internal" href="stochastic.html">pyzag.stochastic</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pyzag</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="api.html">API documentation</a></li>
      <li class="breadcrumb-item active">pyzag.chunktime</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/api/chunktime.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pyzag.chunktime">
<span id="pyzag-chunktime"></span><h1>pyzag.chunktime<a class="headerlink" href="#module-pyzag.chunktime" title="Link to this heading"></a></h1>
<p>Functions and objects to help with blocked/chunked time integration.</p>
<dl class="simple">
<dt>These include:</dt><dd><ol class="arabic simple">
<li><p>Sparse matrix classes for banded systems</p></li>
<li><p>General sparse matrix classes</p></li>
<li><p>Specialized solver routines working with banded systems</p></li>
</ol>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalForwardOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">BidiagonalForwardOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">*args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_operator=&lt;class</span> <span class="pre">'pyzag.chunktime.BidiagonalThomasFactorization'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalForwardOperator" title="Link to this definition"></a></dt>
<dd><p>A batched block banded matrix of the form:</p>
<div class="math">
<p><img src="../_images/math/5708946bb6232e6e60bf487459cb5835f1a86112.png" alt="\begin{bmatrix}
A_1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0\\
B_1 &amp; A_2 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; B_2 &amp; A_3 &amp; 0 &amp; \cdots &amp; 0\\
\vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp; \ddots  &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; B_{n-2} &amp; A_{n-1} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; B_{n-1} &amp; A_n
\end{bmatrix}"/></p>
</div><p>that is, a blocked banded system with the main
diagonal and first lower block diagonal filled</p>
<dl class="simple">
<dt>We use the following sizes:</dt><dd><ul class="simple">
<li><p>nblk: number of blocks in the square matrix</p></li>
<li><p>sblk: size of each block</p></li>
<li><p>sbat: batch size</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.tensor</em>) – tensor of shape (nblk,sbat,sblk,sblk)
storing the nblk diagonal blocks</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – tensor of shape (nblk-1,sbat,sblk,sblk)
storing the nblk-1 off diagonal blocks</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalForwardOperator.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalForwardOperator.forward" title="Link to this definition"></a></dt>
<dd><p><img class="math" src="../_images/math/d72e21fba37c4a4762dc72cac4087f954d42fca0.png" alt="A \cdot v"/> in an efficient manner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – batch of vectors</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalForwardOperator.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalForwardOperator.inverse" title="Link to this definition"></a></dt>
<dd><p>Return an inverse operator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalForwardOperator.matvec">
<span class="sig-name descname"><span class="pre">matvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalForwardOperator.matvec" title="Link to this definition"></a></dt>
<dd><p><img class="math" src="../_images/math/d72e21fba37c4a4762dc72cac4087f954d42fca0.png" alt="A \cdot v"/> in an efficient manner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – batch of vectors</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalForwardOperator.to_diag">
<span class="sig-name descname"><span class="pre">to_diag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalForwardOperator.to_diag" title="Link to this definition"></a></dt>
<dd><p>Convert to a SquareBatchedBlockDiagonalMatrix, for testing
or legacy purposes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalForwardOperator.vecmat">
<span class="sig-name descname"><span class="pre">vecmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalForwardOperator.vecmat" title="Link to this definition"></a></dt>
<dd><p><img class="math" src="../_images/math/e826f9973a5e2ff44106674cb486bf52bcbf29e5.png" alt="v \cdot A"/> in an efficient manner</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – batch of vectors</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalHybridFactorization">
<span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">BidiagonalHybridFactorization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalHybridFactorization" title="Link to this definition"></a></dt>
<dd><p>Apply the hybrid factorization with a given min_size</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalHybridFactorizationImpl">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">BidiagonalHybridFactorizationImpl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalHybridFactorizationImpl" title="Link to this definition"></a></dt>
<dd><p>A factorization approach that switches from PCR to Thomas</p>
<p>Specifically, this class uses PCR until the PCR chunk size is
smaller than user provided minimum chunk size.  Then it switches
to Thomas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.tensor</em>) – tensor of shape (nblk,sbat,sblk,sblk) with the main diagonal</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – tensor of shape (nblk-1,sbat,sblk,sblk) with the off diagonal</p></li>
</ul>
</dd>
<dt class="field-even">Keyword Arguments<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>min_size</strong> (<em>int</em>) – minimum block size, default is zero</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalHybridFactorizationImpl.matvec">
<span class="sig-name descname"><span class="pre">matvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalHybridFactorizationImpl.matvec" title="Link to this definition"></a></dt>
<dd><p>Complete the backsolve for a given right hand side</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – tensor of shape (nblk, sbat, sblk, 1)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">BidiagonalOperator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalOperator" title="Link to this definition"></a></dt>
<dd><p>An object working with a Batched block diagonal operator of the type</p>
<div class="math">
<p><img src="../_images/math/5708946bb6232e6e60bf487459cb5835f1a86112.png" alt="\begin{bmatrix}
A_1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots  &amp; 0\\
B_1 &amp; A_2 &amp; 0 &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; B_2 &amp; A_3 &amp; 0 &amp; \cdots &amp; 0\\
\vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp; \ddots  &amp; \vdots \\
0 &amp; 0 &amp; 0 &amp; B_{n-2} &amp; A_{n-1} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; B_{n-1} &amp; A_n
\end{bmatrix}"/></p>
</div><p>that is, a blocked banded system with the main
diagonal and the first lower diagonal filled</p>
<dl class="simple">
<dt>We use the following sizes:</dt><dd><ul class="simple">
<li><p>nblk:   number of blocks in the square matrix</p></li>
<li><p>sblk:   size of each block</p></li>
<li><p>sbat:   batch size</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.tensor</em>) – tensor of shape (nblk,sbat,sblk,sblk)
storing the nblk main diagonal blocks</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – tensor of shape (nblk-1,sbat,sblk,sblk)
storing the nblk-1 off diagonal blocks</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalOperator.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#pyzag.chunktime.BidiagonalOperator.device" title="Link to this definition"></a></dt>
<dd><p>device, which is just the device of self.diag</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalOperator.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#pyzag.chunktime.BidiagonalOperator.dtype" title="Link to this definition"></a></dt>
<dd><p>dtype, which is just the dtype of self.diag</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalOperator.n">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#pyzag.chunktime.BidiagonalOperator.n" title="Link to this definition"></a></dt>
<dd><p>Size of the unbatched square matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalOperator.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#pyzag.chunktime.BidiagonalOperator.shape" title="Link to this definition"></a></dt>
<dd><p>Logical shape of the dense array</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalPCRFactorization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">BidiagonalPCRFactorization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalPCRFactorization" title="Link to this definition"></a></dt>
<dd><p>Manages the data needed to solve our bidiagonal system via parallel cyclic reduction</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.tensor</em>) – tensor of shape (nblk,sbat,sblk,sblk) with the main diagonal</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – tensor of shape (nblk-1,sbat,sblk,sblk) with the off diagonal</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalPCRFactorization.matvec">
<span class="sig-name descname"><span class="pre">matvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalPCRFactorization.matvec" title="Link to this definition"></a></dt>
<dd><p>Complete the backsolve for a given right hand side</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – tensor of shape (nblk, sbat, sblk)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalThomasFactorization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">BidiagonalThomasFactorization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalThomasFactorization" title="Link to this definition"></a></dt>
<dd><p>Manages the data needed to solve our bidiagonal system via Thomas
factorization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.tensor</em>) – tensor of shape (nblk,sbat,sblk,sblk) with the main diagonal</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – tensor of shape (nblk-1,sbat,sblk,sblk) with the off diagonal</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.BidiagonalThomasFactorization.matvec">
<span class="sig-name descname"><span class="pre">matvec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.BidiagonalThomasFactorization.matvec" title="Link to this definition"></a></dt>
<dd><p>Complete the backsolve for a given right hand side</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – tensor of shape (nblk, sbat, sblk)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.ChunkNewtonRaphson">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">ChunkNewtonRaphson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">miter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">throw_on_fail</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">record_failed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_batches</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.ChunkNewtonRaphson" title="Link to this definition"></a></dt>
<dd><p>Solve a nonlinear system with Newton’s method where the residual and Jacobian are presented as chunked operators</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rtol</strong> (<em>float</em>) – nonlinear relative tolerance</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – nonlinear absolute tolerance</p></li>
<li><p><strong>miter</strong> (<em>int</em>) – maximum number of iterations</p></li>
<li><p><strong>throw_on_fail</strong> (<em>bool</em>) – if True, throw an exception on a failed solve.  If False just issue a warning.</p></li>
<li><p><strong>record_failed</strong> (<em>bool</em>) – if True, store the indices of the bad batches</p></li>
<li><p><strong>ignore_batches</strong> (<em>list</em><em> of </em><em>indices</em>) – if provided, don’t check these batches in evaluating the stopping criteria</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.ChunkNewtonRaphson.not_converged">
<span class="sig-name descname"><span class="pre">not_converged</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nR</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nR0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.ChunkNewtonRaphson.not_converged" title="Link to this definition"></a></dt>
<dd><p>The logical to determine if we’ve converged in a particular time/batch</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nR</strong> (<em>torch.tensor</em>) – current residual</p></li>
<li><p><strong>nR0</strong> (<em>torch.tensor</em>) – original residual</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.ChunkNewtonRaphson.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.ChunkNewtonRaphson.solve" title="Link to this definition"></a></dt>
<dd><p>Actually solve the system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>function</em>) – function that returns the residual and Jacobian (as appropriate chunked operators)</p></li>
<li><p><strong>x0</strong> (<em>torch.tensor</em>) – initial guess, again properly chunked</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>solution</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch.tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.ChunkNewtonRaphson.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">take_step</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.ChunkNewtonRaphson.step" title="Link to this definition"></a></dt>
<dd><p>Take a simple Newton step</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>torch.tensor</em>) – current solution</p></li>
<li><p><strong>dx</strong> (<em>torch.tensor</em>) – newton increment</p></li>
<li><p><strong>fn</strong> (<em>function</em>) – function</p></li>
<li><p><strong>R0</strong> (<em>torch.tensor</em>) – current residual</p></li>
<li><p><strong>take_step</strong> (<em>torch.tensor</em>) – which entries to take a step with</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.ChunkNewtonRaphsonLineSearch">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">ChunkNewtonRaphsonLineSearch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linesearch_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.ChunkNewtonRaphsonLineSearch" title="Link to this definition"></a></dt>
<dd><p>Newton Raphson with backtracking line search</p>
<dl class="field-list simple">
<dt class="field-odd">Keyword Arguments<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rtol</strong> (<em>float</em>) – nonlinear relative tolerance</p></li>
<li><p><strong>atol</strong> (<em>float</em>) – nonlinear absolute tolerance</p></li>
<li><p><strong>miter</strong> (<em>int</em>) – maximum number of iterations</p></li>
<li><p><strong>throw_on_fail</strong> (<em>bool</em>) – if True, throw an exception on a failed solve.  If False just issue a warning.</p></li>
<li><p><strong>record_failed</strong> (<em>bool</em>) – if True, store the indices of the bad batches</p></li>
<li><p><strong>ignore_batches</strong> (<em>list</em><em> of </em><em>indices</em>) – if provided, don’t check these batches in evaluating the stopping criteria</p></li>
<li><p><strong>alpha</strong> (<em>float</em>) – line search cutback</p></li>
<li><p><strong>linesearch_iter</strong> (<em>int</em>) – maximum number of line search iterations</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.ChunkNewtonRaphsonLineSearch.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">take_step</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.ChunkNewtonRaphsonLineSearch.step" title="Link to this definition"></a></dt>
<dd><p>Take a Newton step with backtracking line search</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>torch.tensor</em>) – current solution</p></li>
<li><p><strong>dx</strong> (<em>torch.tensor</em>) – newton increment</p></li>
<li><p><strong>fn</strong> (<em>function</em>) – function</p></li>
<li><p><strong>R0</strong> (<em>torch.tensor</em>) – current residual</p></li>
<li><p><strong>take_step</strong> (<em>torch.tensor</em>) – which entries to take a step with</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.LUFactorization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">LUFactorization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.LUFactorization" title="Link to this definition"></a></dt>
<dd><p>A factorization that uses the LU decomposition of A</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>torch.tensor</em>) – tensor of shape (nblk,sbat,sblk,sblk) with the main diagonal</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – tensor of shape (nblk-1,sbat,sblk,sblk) with the off diagonal</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.LUFactorization.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.LUFactorization.forward" title="Link to this definition"></a></dt>
<dd><p>Run the solve using the linear algebra type interface
with the number of blocks and block size squeezed</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>v</strong> (<em>torch.tensor</em>) – tensor of shape (sbat, sblk*nblk)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">SquareBatchedBlockDiagonalMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diags</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix" title="Link to this definition"></a></dt>
<dd><p>A batched block diagonal matrix of the type</p>
<div class="math">
<p><img src="../_images/math/6116ec9b102a7aa4466f7d337194f6a1bbc14dc2.png" alt="\begin{bmatrix}
A_1 &amp; B_1 &amp; 0 &amp; 0\\
C_1 &amp; A_2 &amp; B_2 &amp; 0 \\
0 &amp; C_2 &amp; A_3 &amp; B_3\\
0 &amp; 0 &amp; C_3 &amp; A_4
\end{bmatrix}"/></p>
</div><p>where the matrix has diagonal blocks of non-zeros and
can have arbitrary numbers of filled diagonals</p>
<p>Additionally, this matrix is batched.</p>
<dl class="simple">
<dt>We use the following sizes:</dt><dd><ul class="simple">
<li><p>nblk: number of blocks in the each direction</p></li>
<li><p>sblk: size of each block</p></li>
<li><p>sbat: batch size</p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>list</em><em> of </em><em>tensors</em>) – list of tensors of length ndiag.
Each tensor
has shape <code class="code docutils literal notranslate"><span class="pre">(nblk-abs(d),sbat,sblk,sblk)</span></code>
where d is the diagonal number
provided in the next input</p></li>
<li><p><strong>diags</strong> (<em>list</em><em> of </em><em>ints</em>) – list of ints of length ndiag.
Each entry gives the diagonal
for the data in the corresponding
tensor.  These values d can
range from -(n-1) to (n-1)</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.device" title="Link to this definition"></a></dt>
<dd><p>device, as reported by the first entry in self.device</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.dtype" title="Link to this definition"></a></dt>
<dd><p>dtype, as reported by the first entry in self.data</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.n">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.n" title="Link to this definition"></a></dt>
<dd><p>Size of the unbatched square matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.nnz">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nnz</span></span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.nnz" title="Link to this definition"></a></dt>
<dd><p>Number of logical non-zeros (not counting the batch dimension)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.shape" title="Link to this definition"></a></dt>
<dd><p>Logical shape of the dense array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_batched_coo">
<span class="sig-name descname"><span class="pre">to_batched_coo</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_batched_coo" title="Link to this definition"></a></dt>
<dd><p>Convert to a torch sparse batched COO tensor</p>
<p>This is done in a weird way.  torch recognizes “batch” dimensions at
the start of the tensor and “dense” dimensions at the end (with “sparse”
dimensions in between).  batch dimensions can/do have difference indices,
dense dimensions all share the same indices.  We have the latter situation
so this is setup as a tensor with no “batch” dimensions, 2 “sparse” dimensions,
and 1 “dense” dimension.  So it will be the transpose of the shape of the
to_dense function.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_dense">
<span class="sig-name descname"><span class="pre">to_dense</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_dense" title="Link to this definition"></a></dt>
<dd><p>Convert the representation to a dense tensor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_unrolled_csr">
<span class="sig-name descname"><span class="pre">to_unrolled_csr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.SquareBatchedBlockDiagonalMatrix.to_unrolled_csr" title="Link to this definition"></a></dt>
<dd><p>Return a list of CSR tensors with length equal to the batch size</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyzag.chunktime.thomas_solve">
<span class="sig-prename descclassname"><span class="pre">pyzag.chunktime.</span></span><span class="sig-name descname"><span class="pre">thomas_solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pivots</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyzag.chunktime.thomas_solve" title="Link to this definition"></a></dt>
<dd><p>Simple function implementing a Thomas solve</p>
<p>Solves in place of v</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lu</strong> (<em>torch.tensor</em>) – factorized diagonal blocks, (nblk,sbat,sblk,sblk)</p></li>
<li><p><strong>pivots</strong> (<em>torch.tensor</em>) – pivots for factorization</p></li>
<li><p><strong>B</strong> (<em>torch.tensor</em>) – lower diagonal blocks (nblk-1,sbat,sblk,sblk)</p></li>
<li><p><strong>v</strong> (<em>torch.tensor</em>) – right hand side (nblk,sbat,sblk)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="nonlinear.html" class="btn btn-neutral float-left" title="pyzag.nonlinear" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ode.html" class="btn btn-neutral float-right" title="pyzag.ode" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Argonne National Laboratory.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>